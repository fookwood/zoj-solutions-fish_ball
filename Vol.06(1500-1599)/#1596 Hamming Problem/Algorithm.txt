Humble Numbers 
　　给定一个素数集合 S = { p[1],p[2],...,p[k] }，大于 1 且素因子都属于 S 的数我们成为丑数（Humble Numbers or Ugly Numbers），记第 n 大的丑数为 h[n]。 

算法 １： 
　　一种最容易想到的方法当然就是从 2 开始一个一个的判断一个数是否为丑数。这种方法的复杂度约为 O( k * h[n])，铁定超时（如果你这样做而没有超时，请跟 tenshi 联系）　　 

算法 ２： 
　　看来只有一个一个地主动生成丑数了　：（ 
　　我最早做这题的时候，用的是一种比较烂的生成方法，复杂度为 O( k * n * log(n) )。 
　　算法流程如下： 
1.初始化最小堆，内置一个元素 1 
2.i=0 ，表示求第 i 个丑数（默认 h[0]=1） 
3.if i>n then goto 7 
4.取出堆中最小的元素 x（如果有多个最小元素，全部取出来）， h[i]:= x，i:=i+1 
5.把 x*p[1] , x*p[2] ... ,x*p[n] 放入堆中 
6.goto 3 
7.结束 
　　这个算法要使用一个最小堆（Heap）的数据结构，各位可以拿这题来练习这种结构。不会超时。 
　　这个附上一个 Pascal 程序，是我初学信息学不久编写的，算法跟前面说的有点点不同，写得比较复杂，仅供参考，各位不要见笑。 

算法 ３： 
　　算法２虽然速度还可以，但是算法复杂度还是有点高。这里介绍一下 UsacoGate 提供的标准程序的算法。首先我们知道这样的东西：如果前 m-1 个丑数已经求出来了（包含 0），那么第 m 个数肯定是由前面某个丑数乘 S 里的素数得来的。假设是 h[pindex[i]] 乘 p[i] 而得到 h[m] 的话，把每次乘 p[i] 的 pindex[i]　列出来，肯定是单调的！利用这个，我们可以得到这样的算法： 
1.nhum=0 ，表示求第 nhum 个丑数（默认 h[0]=1） 
2.令 pindex[i]=0 ，表示一开始无论怎么乘，都是乘 h[0] 
3.if (nhum > n ) then goto 7 
4.分别求出 h[pindex[i]]*p[i]的值，找出比 h[nhum-1] 大的最小值 
5.把这个最小值 h[pindex[minp]]*p[minp] 存入 h[nhum] 
6.nhum:=nhum+1; 
7.结束 
　　这个算法复杂度显然为 O( n * k )，已经相当不错了。这里有 Pascal 和 C++ 版本的程序。 

信息学初学者之家 